import os
import json
import base64
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path
import requests
from pydantic import BaseModel, validator
import logging

logger = logging.getLogger(__name__)

class EnhancedGitHubConfig(BaseModel):
    token: str
    username: str
    email: Optional[str] = None
    
    def is_configured(self) -> bool:
        return bool(self.token and self.username)

class EnhancedCodeFile(BaseModel):
    path: str
    content: str
    language: str
    size: int

class EnhancedGitHubService:
    def __init__(self, config: EnhancedGitHubConfig, generated_dir: Path):
        self.config = config
        self.generated_dir = generated_dir
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"token {config.token}",
            "Accept": "application/vnd.github.v3+json"
        }
    
    def validate_and_get_user_info(self) -> Dict[str, Any]:
        try:
            response = requests.get(f"{self.base_url}/user", headers=self.headers)
            if response.status_code == 200:
                user_data = response.json()
                return {"success": True, "user": {"login": user_data.get("login"), "name": user_data.get("name")}}
            else:
                return {"success": False, "error": f"GitHub API error: {response.status_code}"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def extract_and_organize_generated_code(self) -> Dict[str, Any]:
        try:
            if not self.generated_dir.exists():
                return {"success": False, "error": "Generated directory does not exist"}
            
            files = []
            for file_path in self.generated_dir.glob("*.py"):
                try:
                    content = file_path.read_text(encoding='utf-8')
                    files.append(EnhancedCodeFile(
                        path=file_path.name,
                        content=content, 
                        language='python',
                        size=len(content)
                    ))
                except:
                    continue
            
            if not files:
                return {"success": False, "error": "No Python files found"}
            
            # Add README
            readme = f"""# AI Generated Project

Generated by LilySmokes AI Assistant on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Files
"""
            for file in files:
                readme += f"- `{file.path}` - {file.size} bytes\n"
            
            readme += "\n## Usage\nRun the Python files to see the generated code in action."
            
            readme_file = EnhancedCodeFile(
                path="README.md",
                content=readme,
                language="markdown", 
                size=len(readme)
            )
            files.append(readme_file)
            
            return {
                "success": True,
                "files": files,
                "stats": {
                    "total_files": len(files),
                    "total_size": sum(f.size for f in files)
                }
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def create_repository_with_validation(self, name: str, description: str = "") -> Dict[str, Any]:
        try:
            payload = {
                "name": name,
                "description": description or "Generated by LilySmokes AI Assistant",
                "auto_init": True,
                "gitignore_template": "Python"
            }
            response = requests.post(f"{self.base_url}/user/repos", headers=self.headers, json=payload)
            
            if response.status_code == 201:
                repo_data = response.json()
                return {
                    "success": True,
                    "repository": {
                        "name": repo_data["name"],
                        "html_url": repo_data["html_url"]
                    }
                }
            else:
                return {"success": False, "error": f"Repository creation failed"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def push_files_to_repository(self, repo_name: str, files: List[EnhancedCodeFile], commit_message: str = None) -> Dict[str, Any]:
        try:
            if not commit_message:
                commit_message = f"LilySmokes AI: Generated {len(files)} files"
            
            # Get repo and latest commit
            repo_response = requests.get(f"{self.base_url}/repos/{self.config.username}/{repo_name}", headers=self.headers)
            default_branch = repo_response.json()["default_branch"]
            
            ref_response = requests.get(f"{self.base_url}/repos/{self.config.username}/{repo_name}/git/refs/heads/{default_branch}", headers=self.headers)
            latest_commit_sha = ref_response.json()["object"]["sha"]
            
            commit_response = requests.get(f"{self.base_url}/repos/{self.config.username}/{repo_name}/git/commits/{latest_commit_sha}", headers=self.headers)
            base_tree_sha = commit_response.json()["tree"]["sha"]
            
            # Create blobs and tree
            tree_items = []
            for file in files:
                blob_payload = {
                    "content": base64.b64encode(file.content.encode('utf-8')).decode('utf-8'),
                    "encoding": "base64"
                }
                blob_response = requests.post(f"{self.base_url}/repos/{self.config.username}/{repo_name}/git/blobs", headers=self.headers, json=blob_payload)
                
                if blob_response.status_code == 201:
                    tree_items.append({
                        "path": file.path,
                        "mode": "100644", 
                        "type": "blob",
                        "sha": blob_response.json()["sha"]
                    })
            
            tree_response = requests.post(f"{self.base_url}/repos/{self.config.username}/{repo_name}/git/trees", headers=self.headers, json={"base_tree": base_tree_sha, "tree": tree_items})
            new_tree_sha = tree_response.json()["sha"]
            
            commit_response = requests.post(f"{self.base_url}/repos/{self.config.username}/{repo_name}/git/commits", headers=self.headers, json={"message": commit_message, "tree": new_tree_sha, "parents": [latest_commit_sha]})
            new_commit_sha = commit_response.json()["sha"]
            
            requests.patch(f"{self.base_url}/repos/{self.config.username}/{repo_name}/git/refs/heads/{default_branch}", headers=self.headers, json={"sha": new_commit_sha})
            
            return {
                "success": True,
                "repository": {
                    "name": repo_name,
                    "url": f"https://github.com/{self.config.username}/{repo_name}",
                    "commit_sha": new_commit_sha
                }
            }
        except Exception as e:
            return {"success": False, "error": str(e)}